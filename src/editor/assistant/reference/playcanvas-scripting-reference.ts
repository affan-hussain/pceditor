export type PlayCanvasReferenceSource = {
    title: string;
    summary: string;
};

export type PlayCanvasReferenceSection = {
    id: string;
    title: string;
    summary: string;
    content: string;
};

export type PlayCanvasReferenceMetadata = {
    title: string;
    coverage: string;
    lastUpdated: string;
    sources: PlayCanvasReferenceSource[];
    usageNotes: string[];
};

const METADATA: PlayCanvasReferenceMetadata = {
    title: 'PlayCanvas Scripting Reference (LLM Ready)',
    coverage: 'ESM scripts, lifecycle + events, script attributes, engine API fundamentals, and event-driven communication patterns.',
    lastUpdated: '2025-11-12',
    sources: [
        {
            title: 'ESM Scripts | PlayCanvas Developer Site',
            summary: 'Recommended ES Module workflow for PlayCanvas scripts.'
        },
        {
            title: 'Script Lifecycle | PlayCanvas Developer Site',
            summary: 'Execution order for script methods plus lifecycle events.'
        },
        {
            title: 'ESM Reference (Script Attributes) | PlayCanvas Developer Site',
            summary: 'Declaring, constraining, and grouping script attributes.'
        },
        {
            title: 'Calling the Engine API | PlayCanvas Developer Site',
            summary: 'Common AppBase/Entity/API patterns and math helpers.'
        },
        {
            title: 'Events | PlayCanvas Developer Site',
            summary: 'EventHandler API usage and application-wide event routing.'
        }
    ],
    usageNotes: [
        'Safe to share with LLMs—contains PlayCanvas manual content only.',
        'Request a specific section via its `id` if you only need a subset (ids are returned by the assistant tool).'
    ]
};

const SECTIONS: PlayCanvasReferenceSection[] = [
    {
        id: 'esm-scripts',
        title: 'ESM Scripts and Module Practices',
        summary: 'Modern PlayCanvas scripts use ES Modules (.mjs) for better tooling, modularity, and bundling.',
        content: [
            '#### Overview',
            '- ESM Scripts rely on ES Module syntax, which the PlayCanvas Editor fully supports. They unlock static imports, better bundling, and parity with modern JavaScript workflows.',
            '- Benefits include clearer organization, IDE-friendly structure, and the ability to share helpers via imports instead of globals.',
            '',
            '#### Creating `.mjs` script assets',
            '1. In the **Asset Panel**, create a new script asset.',
            '2. Give the asset a `.mjs` extension (for example `PlayerController.mjs`); PlayCanvas requires this extension for ESM parsing.',
            '3. The Editor seeds the file with an ESM boilerplate so you can focus on logic.',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class PlayerController extends Script {',
            "    static scriptName = 'playerController';",
            '',
            '    initialize() {',
            '        // Setup code here',
            '    }',
            '',
            '    update(dt) {',
            '        // Frame update code here',
            '    }',
            '}',
            '```',
            '',
            '- A single `.mjs` file can export multiple script classes, but you must `export` each class to expose it in the Editor.',
            '',
            '#### Module imports and exports',
            '- Treat supporting files like any ES Module to share constants and helpers.',
            '- Keep related modules nearby (for example `./config.mjs`) to simplify relative imports.',
            '',
            '```ts',
            '// config.mjs – shared configuration',
            'export const GAME_SETTINGS = {',
            '    playerSpeed: 5,',
            '    jumpHeight: 10,',
            '    gravity: -9.8',
            '};',
            '',
            'export function clamp(value, min, max) {',
            '    return Math.min(Math.max(value, min), max);',
            '}',
            '```',
            '',
            '```ts',
            '// PlayerController.mjs – consuming shared code',
            "import { Script } from 'playcanvas';",
            "import { GAME_SETTINGS, clamp } from './config.mjs';",
            '',
            'export class PlayerController extends Script {',
            "    static scriptName = 'playerController';",
            '',
            '    update(dt) {',
            '        const speed = GAME_SETTINGS.playerSpeed;',
            '        // Use clamp or other shared helpers here',
            '    }',
            '}',
            '```'
        ].join('\n')
    },
    {
        id: 'script-lifecycle',
        title: 'Script Lifecycle and Engine Events',
        summary: 'Understand lifecycle methods (`initialize`, `postInitialize`, `update`, `postUpdate`) and lifecycle events (`enable`, `disable`, `state`, `destroy`).',
        content: [
            '#### Overview',
            '- Each script instance attached to an entity follows a predictable lifecycle—think of an actor preparing (`initialize`), performing (`update`), and wrapping up (`destroy`).',
            '- When an entity hosts multiple scripts, the methods run in the order the scripts appear in the Script Component; that order remains consistent every frame.',
            '',
            '#### `initialize()`',
            '- **When it runs:**',
            '  - Once per script instance after the script is created and both the entity and script are enabled.',
            '  - After Script Attributes (defaults or Editor overrides) have been parsed.',
            '  - After the application and hierarchy finish loading but before the first rendered frame.',
            '  - If an entity or script starts disabled, `initialize` runs the first time both are enabled.',
            '- **Purpose:**',
            '  - Perform setup work similar to a constructor.',
            '  - Subscribe to lifecycle events (via `this.on`/`this.once`).',
            '  - Register DOM handlers, create helper objects, and cache entity references.',
            '- **Constructor vs initialize:** Avoid relying on the class constructor because execution order is not guaranteed within the Editor.',
            '- **Cloning entities:** Scripts on a cloned entity do **not** run `initialize` until the clone is added to the scene graph (for example `this.app.root.addChild(clonedEntity)`) and both the entity and script are enabled.',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class MyScript extends Script {',
            "    static scriptName = 'myScript';",
            '',
            '    initialize() {',
            "        this.on('enable', () => console.log('script enabled'));",
            "        this.on('disable', () => console.log('script disabled'));",
            "        this.once('destroy', () => console.log('script destroyed'));",
            '    }',
            '}',
            '```',
            '',
            '#### `postInitialize()`',
            '- **When it runs:** Once per script instance, after the `initialize()` method of **all** enabled scripts has completed.',
            '- **Purpose:** Execute logic that depends on other scripts already finishing their initialization (avoids race conditions).',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class MyScript extends Script {',
            "    static scriptName = 'myScript';",
            '',
            '    initialize() {',
            "        this.otherEntity = this.app.root.findByName('OtherEntity');",
            '    }',
            '',
            '    postInitialize() {',
            '        const material = this.otherEntity.material;',
            '        // Safe to use because every initialize already ran',
            '    }',
            '}',
            '```',
            '',
            '#### `update(dt)`',
            '- **When it runs:** Every frame while the script, its entity, and all ancestor entities remain enabled.',
            '- **Parameter:** `dt` (delta time in seconds) equals the elapsed time since the previous frame, which keeps logic frame-rate independent.',
            '- **Purpose:**',
            '  - Handle continuous input.',
            '  - Update transforms for movement/animation.',
            '  - Evaluate game conditions such as collisions or win/loss checks.',
            '- **Performance note:** Keep `update` lean; heavy allocations here can hurt frame rates.',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class Rotator extends Script {',
            "    static scriptName = 'rotator';",
            '',
            '    update(dt) {',
            '        // Rotate 10 degrees per second around world Y',
            '        this.entity.rotate(0, 10 * dt, 0);',
            '    }',
            '}',
            '```',
            '',
            '#### `postUpdate(dt)`',
            '- **When it runs:** Every frame after **all** scripts have completed their `update()` for that frame.',
            '- **Purpose:** Run logic that must react to other scripts’ updates (for example, a camera that follows the player after the player moves).',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class TrackingCamera extends Script {',
            "    static scriptName = 'trackingCamera';",
            '',
            '    initialize() {',
            "        this.player = this.app.root.findByName('Player');",
            '    }',
            '',
            '    postUpdate(dt) {',
            '        const playerPos = this.player.getPosition();',
            '        this.entity.lookAt(playerPos);',
            '    }',
            '}',
            '```',
            '',
            '#### Lifecycle events (`enable`, `disable`, `state`, `destroy`)',
            '- Scripts also emit lifecycle events that you can observe via `this.on` and clean up via `this.off`.',
            '',
            '- **`enable` event:**',
            '  - Fires when the script becomes enabled (initial enable, toggling `this.enabled` to true, or enabling an ancestor entity).',
            '  - Use it to resume behaviors, re-register listeners, or update visuals.',
            '  - Example:',
            '    ```ts',
            "    this.on('enable', () => console.log('script enabled'));",
            '    ```',
            '  - If a script starts enabled, the handler fires during initialization; call it manually if you also need immediate side effects.',
            '',
            '- **`disable` event:**',
            '  - Fires when the script becomes disabled (setting `this.enabled = false`, disabling the entity/ancestor, or right before destruction).',
            '  - Use it to pause behaviors, unregister listeners, or release temporary resources.',
            '',
            '- **`state` event:**',
            '  - Fires whenever the effective running state toggles (enabled ↔ disabled) due to script, component, or entity changes.',
            '  - The handler receives the new boolean state.',
            '',
            '- **`destroy` event:**',
            '  - Fires immediately before the script instance is destroyed (entity destroyed, script component removed, or explicit `this.destroy()`).',
            '  - Use it for final cleanup: unsubscribe from app/entity events, release DOM nodes, and null references for garbage collection.',
            "  - Subscribe with `this.once('destroy', () => {/* cleanup */})` so the handler runs exactly once.",
            '- **Cleanup reminder:** Any listener registered with `on`/`once` should be removed (via `off`) during destroy to prevent leaks.'
        ].join('\n')
    },
    {
        id: 'script-attributes',
        title: 'Script Attributes (ESM)',
        summary: 'Expose script members to the Editor, add constraints, create groups, and control visibility/enablement.',
        content: [
            '#### Overview',
            '- Attributes turn script members into Editor controls, letting collaborators tweak per-entity values without editing code.',
            '- Declare them with the `@attribute` tag; the Editor injects UI for each entity instance.',
            '',
            '```ts',
            "import { Script } from 'playcanvas';",
            '',
            'export class Rotator extends Script {',
            "    static scriptName = 'rotator';",
            '    /**',
            '     * You can now set the `speed` property dynamically in the Editor.',
            '     * @attribute',
            '     */',
            '    speed = 2;',
            '',
            '    update(dt) {',
            '        this.entity.rotateLocal(0, this.speed * dt, 0);',
            '    }',
            '}',
            '```',
            '- Because attributes are just class members, read/write them like `this.speed`.',
            '',
            '#### Editor parsing and UI',
            '- After changing attribute definitions, click the **Parse** button so the Editor rescans the script and refreshes controls.',
            '',
            '#### Attribute descriptions and constraints',
            '- The first sentence of an `@attribute` block becomes the tooltip/description.',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * Sets the speed of the Y rotation in degrees.',
            '   */',
            '  speed = 2;',
            '  ```',
            '- Constraint tags shape the UI:',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @range [0, 10]',
            '   * @precision 0.1',
            '   * @step 0.05',
            '   */',
            '  speed = 10;',
            '  ```',
            '- `@range` sets slider min/max, `@precision` controls decimal display, and `@step` defines increments.',
            '',
            '#### Supported attribute types and `@type`',
            '- Primitive/math: `number`, `string`, `boolean`, `Vec2`, `Vec3`, `Vec4`, `Color`.',
            '- References: `Entity`, `Asset`, `Curve`, or custom grouped objects.',
            '- Every attribute must either have an initializer (`speed = 10`) **or** a `@type {Type}` annotation—otherwise it is ignored (per the PlayCanvas warning).',
            '- Use `@type` when the initial value is unknown:',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @type {Asset}',
            '   */',
            '  myTexture;',
            '  ```',
            '',
            '#### Specialized attribute patterns',
            '- **Entity attribute:** Reference another entity; remember to `import { Entity } from \'playcanvas\'`.',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @type {Entity}',
            '   */',
            '  target;',
            '  ```',
            '- **Asset attribute with `@resource`:** Restrict selection to a specific asset type and access both the asset and resource.',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @type {Asset}',
            '   * @resource texture',
            '   */',
            '  texture;',
            '',
            '  initialize() {',
            "      console.log('This is the texture asset', this.texture);",
            "      console.log('This is the texture resource', this.texture.resource);",
            '  }',
            '  ```',
            '- **Color attribute:**',
            '  ```ts',
            '  /** @attribute */',
            '  color = new Color();',
            '  ```',
            '  Choose RGB or RGBA editing; import `Color` from `playcanvas`.',
            '- **Vector attribute:** Works with `Vec2`, `Vec3`, or `Vec4` and renders per-component inputs.',
            '  ```ts',
            '  /** @attribute */',
            '  position = new Vec3();',
            '  ```',
            '- **Curve attribute:** Define values that change over normalized time.',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @type {Curve}',
            '   * @color rgba',
            '   */',
            '  wave;',
            '  ```',
            '  Curves exist over 0.0–1.0; use the `curves` property for multi-channel data (e.g., x/y/z). Import `Curve` from `playcanvas`.',
            '',
            '#### Attribute arrays',
            '- Expose arbitrary-length lists via array annotations:',
            '  ```ts',
            '  /**',
            '   * @attribute',
            '   * @type {Color[]}',
            '   */',
            '  gradientStops;',
            '',
            '  initialize() {',
            '      this.gradientStops.forEach((color) => {',
            "          console.log('This is a Color class', color);",
            '      });',
            '  }',
            '  ```',
            '',
            '#### Enumerations',
            '- Use `@enum` plus `@type {EnumName}` to restrict values and surface a dropdown.',
            '  ```ts',
            '  /** @enum {number} */',
            '  const Lights = {',
            '      ON: 1,',
            '      OFF: 0,',
            '      UNKNOWN: 0.5',
            '  };',
            '',
            '  class MyScript extends Script {',
            "      static scriptName = 'myScript';",
            '      /**',
            '       * @attribute',
            '       * @type {Lights}',
            '       */',
            '      ambient = Lights.OFF;',
            '  }',
            '  ```',
            '- Enumerator values must be numbers, strings, or booleans. The Editor labels dropdown options with the enum keys (`ON`, `OFF`, `UNKNOWN`).',
            '',
            '#### Conditional attributes',
            '- Drive enablement or visibility from other attribute values using expressions.',
            '  ```ts',
            '  export class Delorean extends Script {',
            "      static scriptName = 'delorean';",
            '      /**',
            '       * @attribute',
            '       */',
            '      power = false;',
            '      /**',
            '       * @attribute',
            '       * @enabledif {power}',
            '       */',
            '      speed = 10;',
            '      /**',
            '       * @attribute',
            '       * @visibleif {speed > 88.8}',
            '       */',
            '      enableFluxCapacitor = true;',
            '  }',
            '  ```',
            '- `@enabledif {expression}` disables a control until the expression is truthy; `@visibleif` hides it entirely. The manual includes an “Example in Action” animation demonstrating these conditions.',
            '',
            '#### Grouping attributes',
            '- Attribute Groups bundle related fields into an object, keeping the Inspector tidy.',
            '- **Inline group:**',
            '  ```ts',
            '  class GameLogic extends Script {',
            "      static scriptName = 'gameLogic';",
            '      /** @attribute */',
            '      enemy = { power: 10, speed: 3 };',
            '  }',
            '  ```',
            '- **TypeDef group (reusable):**',
            '  ```ts',
            '  /**',
            '   * @typedef {Object} Enemy',
            "   * @prop {number} speed - The enemy's speed",
            "   * @prop {number} power - The enemy's power",
            '   */',
            '  class GameLogic extends Script {',
            "      static scriptName = 'gameLogic';",
            '      /**',
            '       * @attribute',
            '       * @type {Enemy}',
            '       */',
            '      enemy;',
            '  }',
            '  ```',
            '- Attribute Groups let you organize related controls into object-based structures instead of dozens of standalone attributes.',
            '',
            '#### Interface attributes',
            '- Use `@interface` to define reusable structured groups where each public member becomes a sub-attribute (with its own constraints).',
            '  ```ts',
            '  /** @interface */',
            '  class Enemy {',
            '      /**',
            '       * @range [0, 11]',
            '       */',
            '      power = 10;',
            '      speed = 3;',
            '  }',
            '',
            '  class GameLogic extends Script {',
            "      static scriptName = 'gameLogic';",
            '      /**',
            '       * @attribute',
            '       * @type {Enemy}',
            '       */',
            '      enemy;',
            '  }',
            '  ```',
            '- **Rules:**',
            '  - The interface must be preceded by an `/** @interface */` block.',
            '  - Script attributes reference it via `@type {InterfaceName}`.',
            '  - All public members automatically become Editor controls (no extra `@attribute` tags).',
            '  - Nested interface attributes are not supported.',
            '',
            '#### Interface attribute arrays',
            '- Combine interfaces with array syntax to expose structured lists.',
            '  ```ts',
            '  class GameLogic extends Script {',
            "      static scriptName = 'gameLogic';",
            '      /**',
            '       * @attribute',
            '       * @type {Enemy[]}',
            '       */',
            '      enemies;',
            '',
            '      update(dt) {',
            '          this.enemies.forEach(({ power, speed }) => {',
            '              this.updateEnemy(power, speed);',
            '          });',
            '      }',
            '  }',
            '  ```',
        ].join('\n')
    },
    {
        id: 'engine-api',
        title: 'Calling the Engine API',
        summary: 'Key PlayCanvas classes, math helpers, and scripting patterns.',
        content: [
            '#### Overview',
            '- PlayCanvas scripts interact with the PlayCanvas Engine API; keep the reference handy for deeper use cases.',
            '',
            '#### Script context (`this.app`, `this.entity`)',
            '- `this.app` exposes the `AppBase` application and its systems.',
            '- `this.entity` references the entity that owns the script.',
            '- These properties are valid inside script instance methods (e.g., `initialize`, `update`). Review MDN for JavaScript `this` semantics if needed.',
            '',
            '```ts',
            'this.app;   // AppBase',
            'this.entity; // Entity',
            '```',
            '',
            '#### Essential classes and typical operations',
            '- **AppBase** — manages app-wide state.',
            '  ```ts',
            "  this.app.fire('game:start');",
            "  const player = this.app.root.findByName('Player');",
            "  const texture = this.app.assets.find('logo', 'texture');",
            '  ```',
            '- **Entity** — scene objects.',
            '  ```ts',
            '  this.entity.setPosition(0, 5, 0);',
            '  this.entity.rotate(0, 90, 0);',
            "  const child = this.entity.findByName('Weapon');",
            '  ```',
            '- **Component** — functionality modules.',
            '  ```ts',
            '  const camera = this.entity.camera;',
            '  const light = this.entity.light;',
            '  const rigidbody = this.entity.rigidbody;',
            '  const sound = this.entity.sound;',
            '  ```',
            '',
            '#### Math classes',
            '- Import math helpers for transforms, rotations, and colors.',
            '  ```ts',
            "  import { Vec3, Quat, Color } from 'playcanvas';",
            '  const position = new Vec3(0, 5, 0);',
            '  const rotation = new Quat();',
            '  const red = new Color(1, 0, 0);',
            '  ```',
            '',
            '#### Common script patterns',
            '- **Finding entities:**',
            '  ```ts',
            "  const player = this.app.root.findByName('Player'); // searches entire hierarchy",
            "  const enemies = this.app.root.findByTag('enemy');  // returns an array",
            "  const weapon = this.entity.findByPath('Arms/RightHand/Weapon');",
            '  ```',
            '- **Working with assets:**',
            '  ```ts',
            "  const sound = this.app.assets.find('explosion', 'audio');",
            '  sound.ready(() => {',
            "      this.entity.sound.play('explosion');",
            '  });',
            '  this.app.assets.load(sound);',
            '  ```',
            '- **Events and communication:**',
            '  ```ts',
            "  this.app.fire('player:died', this.entity);",
            "  this.app.on('game:start', this.onGameStart, this);",
            '  ```',
            '',
            '#### Learning more & tooling',
            '- **Full Engine API Reference** — comprehensive class/method docs.',
            '- **Engine Guide** — deeper runtime coverage.',
            '- **Script Lifecycle** — revisit lifecycle timing details.',
            '- **Events** — additional communication patterns.'
        ].join('\n')
    },
    {
        id: 'events',
        title: 'Events and Application-Level Messaging',
        summary: 'Use EventHandler APIs for script-to-script communication, including `this.app` as an event hub.',
        content: [
            '#### Overview',
            '- Events let scripts communicate without polling each frame.',
            '- Objects derived from the Engine EventHandler class—script instances, entities, and `this.app`—support:',
            '  - `on(event, handler)` — register a listener.',
            '  - `once(event, handler)` — register a listener that removes itself after firing.',
            '  - `off(event, handler)` — remove a listener.',
            '  - `fire(event, ...args)` — emit an event.',
            '  - `hasEvent(event)` — check for listeners.',
            '',
            '#### Using events on specific entities/scripts',
            '- Fire events from the script that owns the behavior and listen from another script that references that entity.',
            '  ```ts',
            "  import { Script } from 'playcanvas';",
            '',
            '  export class Player extends Script {',
            "      static scriptName = 'player';",
            '',
            '      update(dt) {',
            '          const x = 1;',
            '          const y = 1;',
            "          this.fire('move', x, y);",
            '      }',
            '  }',
            '',
            '  export class Display extends Script {',
            "      static scriptName = 'display';",
            '      /**',
            '       * @attribute',
            '       * @type {Entity}',
            '       */',
            '      playerEntity;',
            '',
            '      initialize() {',
            '          const onPlayerMove = (x, y) => {',
            '              console.log(x, y);',
            '          };',
            '',
            '          if (this.playerEntity?.script?.player) {',
            "              this.playerEntity.script.player.on('move', onPlayerMove);",
            "              this.playerEntity.script.player.once('destroy', () => {",
            "                  this.playerEntity.script.player.off('move', onPlayerMove);",
            '              });',
            '          }',
            '      }',
            '  }',
            '  ```',
            '- Always unregister listeners (for example in `destroy`) so they do not outlive the entity.',
            '',
            '#### Application events (`this.app` as a hub)',
            '- Instead of storing references to specific entities, fire namespaced events on `this.app` (for example `player:move`).',
            '- Namespacing signals scope and avoids clashes when many systems listen for events.',
            '- Example:',
            '  ```ts',
            "  import { Script } from 'playcanvas';",
            '',
            '  export class Player extends Script {',
            "      static scriptName = 'player';",
            '',
            '      update(dt) {',
            '          const x = 1;',
            '          const y = 1;',
            "          this.app.fire('player:move', x, y);",
            '      }',
            '  }',
            '',
            '  export class Display extends Script {',
            "      static scriptName = 'display';",
            '',
            '      initialize() {',
            '          const onPlayerMove = (x, y) => {',
            '              console.log(x, y);',
            '          };',
            '',
            "          this.app.on('player:move', onPlayerMove);",
            "          this.on('destroy', () => {",
            "              this.app.off('player:move', onPlayerMove);",
            '          });',
            '      }',
            '  }',
            '  ```',
            '- Application events minimize setup overhead and result in cleaner code when multiple systems need the same information.',
            ''
        ].join('\n')
    }
];

const renderMetadataBlock = () => {
    const lines = [
        `# ${METADATA.title}`,
        '',
        `Last updated: ${METADATA.lastUpdated}`,
        `Coverage: ${METADATA.coverage}`,
        '',
        'Sources:',
        ...METADATA.sources.map((source) => `- ${source.title} — ${source.summary}`)
    ];

    if (METADATA.usageNotes.length) {
        lines.push('', 'Usage notes:', ...METADATA.usageNotes.map((note) => `- ${note}`));
    }

    return lines.join('\n');
};

const renderSectionBlock = (section: PlayCanvasReferenceSection) => [
    `## ${section.title}`,
    '',
    section.summary,
    '',
    section.content
].join('\n');

const buildMarkdown = (sectionId?: string | null) => {
    const trimmedId = typeof sectionId === 'string' ? sectionId.trim() : '';
    const sectionsToRender = trimmedId
        ? SECTIONS.filter((section) => section.id === trimmedId)
        : SECTIONS;

    if (trimmedId && !sectionsToRender.length) {
        throw new Error(`Unknown PlayCanvas reference section "${trimmedId}". Available ids: ${SECTIONS.map((section) => section.id).join(', ')}`);
    }

    const parts = [
        renderMetadataBlock(),
        sectionsToRender.map((section) => renderSectionBlock(section)).join('\n\n')
    ].filter(Boolean);

    return parts.join('\n\n');
};

export const PLAYCANVAS_SCRIPTING_REFERENCE_METADATA = METADATA;
export const PLAYCANVAS_SCRIPTING_REFERENCE_SECTIONS = SECTIONS;
export const PLAYCANVAS_SCRIPTING_REFERENCE_MARKDOWN = buildMarkdown();
export const getPlayCanvasReferenceMarkdown = (sectionId?: string | null) => buildMarkdown(sectionId);
